
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Ispoon</title>
        <meta name="author" content="ispoon">
        <meta name="description" content="">
        <meta name="keywords" content="">
        <link rel="icon" href="images/icon.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>

        <div id="L2dCanvas"></div>
        <script src="/js/live2d.min.js"></script>
        <script src="/css/live2d.css"></script>
        <script>
            var v = new Viewer({
                width: 240,
                height: 325,
                right: "0",
                bottom: "0",
                basePath: "/model",
                role: "dunkeerke_2",
                mobile: true,
            });
        </script>
        <canvas id="fireworks" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:2147483647"></canvas>
        <script src="/js/fireworks.js"></script>
        <canvas id="background" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1"></canvas><script src="/js/background.js"></script>
        <div id="cursor"></div>
        <script src="/css/cursor.css"></script>
        <script src="/js/cursor.js"></script>
        
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ispoon</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ispoon</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(images/background.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ispoon</h1>
                <h3>ispoon の 窝</h3>
                <h5></h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/09/11/vue-学习-4/">
        <h2 class="post-title">Vue-学习-4</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/11
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>主要介绍了列表渲染以及事件处理等方面的知识</p>
<h1 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a><code>v-for</code></h1><p>我们可以使用<code>v-for</code>指令基于一个数组来渲染一个列表。<code>v-for</code>指令的值需要使用<code>item in items</code>形式的特殊语法，其中<code>items</code>是源数据的数组，而<code>item</code>是迭代项的别名：</p>
<pre><code class="js">const items = ref([&#123; message: &#39;Foo&#39; &#125;, &#123; message: &#39;Bar&#39; &#125;])
</code></pre>
<pre><code class="template">&lt;li v-for=&quot;item in items&quot;&gt;
  &#123;&#123; item.message &#125;&#125;
&lt;/li&gt;
</code></pre>
<p>在<code>v-for</code>块中可以完整的访问父作用域内的属性和变量。<code>v-for</code>也支持使用可选的第二个参数表示当前项的位置索引。</p>
<pre><code class="js">const parentMessage = ref(&#39;Parent&#39;)
const items = ref([&#123; message: &#39;Foo&#39; &#125;, &#123; message: &#39;Bar&#39; &#125;])
</code></pre>
<pre><code class="template">&lt;li v-for=&quot;(item, index) in items&quot;&gt;
  &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;
&lt;/li&gt;
</code></pre>
<p><img src="/2022/09/11/vue-%E5%AD%A6%E4%B9%A0-4/1.png" alt="列表展示的效果"></p>
<p><code>v-for</code>变量的作用域和下面的JavaScript代码很类似：</p>
<pre><code class="js">const parentMessage = &#39;Parent&#39;
const items = [
  /* ... */
]

items.forEach((item, index) =&gt; &#123;
  // 可以访问外层的 `parentMessage`
  // 而 `item` 和 `index` 只在这个作用域可用
  console.log(parentMessage, item.message, index)
&#125;)
</code></pre>
<p>注意<code>v-for</code>是如何对应<code>forEach</code>回调的函数签名的，实际上，你也可以在定义<code>v-for</code>的变量别名时使用解构，和解构函数参数类似：</p>
<pre><code class="template">&lt;li v-for=&quot;&#123; message &#125; in items&quot;&gt;
  &#123;&#123; message &#125;&#125;
&lt;/li&gt;

&lt;!-- 有 index 索引时 --&gt;
&lt;li v-for=&quot;(&#123; message &#125;, index) in items&quot;&gt;
  &#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;
&lt;/li&gt;
</code></pre>
<p>对于多层嵌套的<code>v-for</code>，作用域的工作方式和函数的作用域很相似。每个<code>v-for</code>作用域都可以访问到父级作用域</p>
<pre><code class="template">&lt;li v-for=&quot;item in items&quot;&gt;
  &lt;span v-for=&quot;childItem in item.children&quot;&gt;
    &#123;&#123; item.message &#125;&#125; &#123;&#123; childItem &#125;&#125;
  &lt;/span&gt;
&lt;/li&gt;
</code></pre>
<p>你可以使用<code>of</code>作为分割符来替换<code>in</code>，这更接近JavaScript的迭代器语法</p>
<pre><code class="template">&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;
</code></pre>
<h2 id="v-for与对象"><a href="#v-for与对象" class="headerlink" title="v-for与对象"></a><code>v-for</code>与对象</h2><p>你也可以使用<code>v-for</code>来遍历一个对象的所有属性。遍历的顺序会基于对于该对象的调用<code>object.keys()</code>的返回值决定。</p>
<pre><code class="js">const myObject = reactive(&#123;
  title: &#39;How to do lists in Vue&#39;,
  author: &#39;Jane Doe&#39;,
  publishedAt: &#39;2016-04-10&#39;
&#125;)
</code></pre>
<pre><code class="template">&lt;ul&gt;
  &lt;li v-for=&quot;value in myObject&quot;&gt;
    &#123;&#123; value &#125;&#125;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>可以通过提供第二个参数表示属性名（例如key):</p>
<pre><code class="template">&lt;li v-for=&quot;(value, key) in myObject&quot;&gt;
  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;
&lt;/li&gt;
</code></pre>
<p>第三个参数表示位置索引：</p>
<pre><code class="template">&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;
  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;
&lt;/li&gt;
</code></pre>
<h2 id="在v-for里使用范围值"><a href="#在v-for里使用范围值" class="headerlink" title="在v-for里使用范围值"></a>在<code>v-for</code>里使用范围值</h2><p><code>v-for</code>可以直接接受一个整数值。在这种用例中，会将该魔板基于<code>1...n</code>的取值范围重复多次</p>
<pre><code class="template">&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;
</code></pre>
<p>注意此处<code>n</code>的初始是从<code>1</code>开始而并非是<code>0</code></p>
<h2 id="lt-template-gt-上的v-for"><a href="#lt-template-gt-上的v-for" class="headerlink" title="&lt;template&gt;上的v-for"></a><code>&lt;template&gt;</code>上的<code>v-for</code></h2><p>与模板上的<code>v-if</code>类似，你也可以在<code>&lt;template&gt;</code>标签上使用<code>v-for</code>来渲染一个包含多个元素的块。例如：</p>
<pre><code class="template">&lt;ul&gt;
  &lt;template v-for=&quot;item in items&quot;&gt;
    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;
    &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt;
  &lt;/template&gt;
&lt;/ul&gt;
</code></pre>
<h2 id="v-for与v-if"><a href="#v-for与v-if" class="headerlink" title="v-for与v-if"></a><code>v-for</code>与<code>v-if</code></h2><p>当它们同时存在与一个节点上时，<code>v-if</code>比<code>v-for</code>的优先级更高。这意味着<code>v-if</code>的条件将无法访问到<code>v-for</code>的作用域内定义的变量别名。</p>
<pre><code class="template">&lt;!--
 这会抛出一个错误，因为属性 todo 此时
 没有在该实例上定义
--&gt;
&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;
  &#123;&#123; todo.name &#125;&#125;
&lt;/li&gt;
</code></pre>
<p>在新外包装一层<code>&lt;template&gt;</code>再在其上使用<code>v-for</code>可以解决这个问题（这也更加明显易读）：</p>
<pre><code class="template">&lt;template v-for=&quot;todo in todos&quot;&gt;
  &lt;li v-if=&quot;!todo.isComplete&quot;&gt;
    &#123;&#123; todo.name &#125;&#125;
  &lt;/li&gt;
&lt;/template&gt;
</code></pre>
<h2 id="通过key管理状态"><a href="#通过key管理状态" class="headerlink" title="通过key管理状态"></a>通过key管理状态</h2><p>vue默认按照“就地更新”的策略来通过<code>v-for</code>渲染的元素列表。但数据项的顺序改变时，vue不会随着移动DOM元素的顺序，而是就地的更新每个元素，确保他们在原本指定的索引位置上渲染。<br>默认模式是高效的，但只适用于列表渲染输出的结果不依赖于子组件状态或是临时的DOM状态（例如表单输入值）的情况。<br>为了给vue一个提示，以便他可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个惟一的key的attribute</p>
<pre><code class="template">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;
  &lt;!-- 内容 --&gt;
&lt;/div&gt;
</code></pre>
<p>当你使用<code>&lt;template v-for&gt;</code>时，<code>key</code>应该被放置在这个<code>&lt;template&gt;</code>容器上：</p>
<pre><code class="template">&lt;template v-for=&quot;todo in todos&quot; :key=&quot;todo.name&quot;&gt;
  &lt;li&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;
&lt;/template&gt;
</code></pre>
<p>推荐在任何可行的时候为<code>v-for</code>提供一个<code>key</code>attribute，除非所迭代的DOM内容非常简单（例如：不包含组件或有状态的DOM元素），或者你想有意采用默认行为来提供性能。<br><code>key</code>绑定的期望值是一个基础类型的值，例如字符串或是number类型。不要用对象作为<code>v-for</code>的key。</p>
<h2 id="组件上使用v-for"><a href="#组件上使用v-for" class="headerlink" title="组件上使用v-for"></a>组件上使用<code>v-for</code></h2><p>我们可以直接在组件上使用<code>v-for</code>，和在一般的元素上使用没有区别（别忘记提供一个key）：</p>
<pre><code class="template">&lt;MyComponent v-for=&quot;item in items&quot; :key=&quot;item.id&quot; /&gt;
</code></pre>
<p>但是，这不会自动的将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组建中，我们还需要传递props：</p>
<pre><code class="template">&lt;MyComponent
  v-for=&quot;(item, index) in items&quot;
  :item=&quot;item&quot;
  :index=&quot;index&quot;
  :key=&quot;item.id&quot;
/&gt;
</code></pre>
<p>不自动将<code>item</code>注入组件的原因是，这会使组件与<code>v-for</code>的工作方式紧密耦合。明确其数据的来源可以使组件在洽情况下重用。</p>
<h2 id="数组变换侦测"><a href="#数组变换侦测" class="headerlink" title="数组变换侦测"></a>数组变换侦测</h2><h3 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h3><p>vue能够侦听响应式数组的变更方式，并在他们被调用的时候触发相关的更新。这些变更方法包括<br><code>push()</code><br><code>pop()</code><br><code>shift()</code><br><code>unshift()</code><br><code>splice()</code><br><code>sort()</code><br><code>reverse()</code></p>
<h3 id="替换一个数组"><a href="#替换一个数组" class="headerlink" title="替换一个数组"></a>替换一个数组</h3><p>变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对的，也有一些不可变（immutable)方法，例如<code>filter()</code>，<code>concat()</code>和<code>slice()</code>，这些都不会更改为原数组，而总是返回一个新的数组。当遇到的是非变更方法时，我们需要姜旧的数组替换为新的:</p>
<pre><code class="js">// `items` 是一个数组的 ref
items.value = items.value.filter((item) =&gt; item.message.match(/Foo/))
</code></pre>
<p>你可能认为这将导致vue丢弃现有的DOM并重新渲染整个列表，幸运的是，情况并非如此。vue实现了一些巧妙地方法来最大化对DOM元素的重用，因此用另一个包含部分冲得对象的数组来替换，仍会是一种非常高效的操作。</p>
<h2 id="展示过滤或排序后的结果"><a href="#展示过滤或排序后的结果" class="headerlink" title="展示过滤或排序后的结果"></a>展示过滤或排序后的结果</h2><p>有时，我们希望显示数组经过过滤或者排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回过滤或已排序数组的计算属性<br>举例来说</p>
<pre><code class="js">const numbers = ref([1, 2, 3, 4, 5])

const evenNumbers = computed(() =&gt; &#123;
  return numbers.value.filter((n) =&gt; n % 2 === 0)
&#125;)
</code></pre>
<pre><code class="template">&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;
</code></pre>
<p>在计算属性不可行的情况下（例如在多层嵌套<code>v-for</code>循环中）,你可以使用以下方法：</p>
<pre><code class="js">const sets = ref([
  [1, 2, 3, 4, 5],
  [6, 7, 8, 9, 10]
])

function even(numbers) &#123;
  return numbers.filter((number) =&gt; number % 2 === 0)
&#125;
</code></pre>
<pre><code class="template">&lt;ul v-for=&quot;numbers in sets&quot;&gt;
  &lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>在计算属性中使用<code>reverse()</code>和<code>sort()</code>的时候务必小心！这两个方法将变成原始数据，计算函数中不应该这样做。请在调用这些方法之前创建一个原数组的父本</p>
<pre><code class="diff">- return numbers.reverse()
+ return [...numbers].reverse()
</code></pre>
<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>我们可以使用<code>v-on</code>指令（简写成<code>@</code>)来监听DOM事件，并在事件触发时执行对应的JavaScrpit。用法<code>v-on:click=&#39;methodName&#39;或者</code>@click&#x3D;’handler’<code>。 事件处理器的值可以是： 1.**内联事件处理器**：事件被触发时执行的内联JavaScript语句（与</code>onclick&#96;&#96;&#96;类似）。<br>2.<strong>方法事件处理器</strong>：一个指向组件上定义的方法属性名或是路径。</p>
<h2 id="内联事件处理器"><a href="#内联事件处理器" class="headerlink" title="内联事件处理器"></a>内联事件处理器</h2><p>内联事件处理器通常用于简单场景，例如：</p>
<pre><code class="js">const count = ref(0)
</code></pre>
<pre><code class="template">&lt;button @click=&quot;count++&quot;&gt;Add 1&lt;/button&gt;
&lt;p&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/p&gt;
</code></pre>
<h2 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h2><p>随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此<code>v-on</code>也可以接受一个方法名对某个方法的调用：<br>举例来说：</p>
<pre><code class="js">const name = ref(&#39;Vue.js&#39;)

function greet(event) &#123;
  alert(`Hello $&#123;name.value&#125;!`)
  // `event` 是 DOM 原生事件
  if (event) &#123;
    alert(event.target.tagName)
  &#125;
&#125;
</code></pre>
<pre><code class="template">&lt;!-- `greet` 是上面定义过的方法名 --&gt;
&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;
</code></pre>
<p>方法事件处理器会自动接收原生DOM事件并触发执行函数。在上面的例子中，我们能够通过被触发事件的<code>event.target.tagName</code>访问到该DOM 元素。</p>
<h3 id="方法与内联事件判断"><a href="#方法与内联事件判断" class="headerlink" title="方法与内联事件判断"></a>方法与内联事件判断</h3><p>模板编译器会通过检查<code>v-on</code>的值是否合法的JavaScript标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，<code>foo</code>、<code>foo.bar</code>和<code>foo[&#39;bar&#39;]</code>会被视为方法事件处理器，而<code>foo()</code>和&#96;&#96;&#96;count++&#96;&#96;会视为内联事件处理器。</p>
<h2 id="在内联处理器中调用方法"><a href="#在内联处理器中调用方法" class="headerlink" title="在内联处理器中调用方法"></a>在内联处理器中调用方法</h2><p>除了直接绑定方法名，你还可以在内联事件处理器中调用方法，这允许我们向方法传入自定义参数以替代原生事件：</p>
<pre><code class="js">function say(message) &#123;
  alert(message)
&#125;
</code></pre>
<pre><code class="template">&lt;button @click=&quot;say(&#39;hello&#39;)&quot;&gt;Say hello&lt;/button&gt;
&lt;button @click=&quot;say(&#39;bye&#39;)&quot;&gt;Say bye&lt;/button&gt;
</code></pre>
<h2 id="在内联事件处理器中访问事件的参数"><a href="#在内联事件处理器中访问事件的参数" class="headerlink" title="在内联事件处理器中访问事件的参数"></a>在内联事件处理器中访问事件的参数</h2><p>有时，我们需要在内联事件处理器中访问原生的DOM事件。你可以向该处理器方法出入一个特殊的<code>$event</code>，或者使用内联箭头函数：</p>
<pre><code class="template">&lt;!-- 使用特殊的 $event 变量 --&gt;
&lt;button @click=&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt;
  Submit
&lt;/button&gt;

&lt;!-- 使用内联箭头函数 --&gt;
&lt;button @click=&quot;(event) =&gt; warn(&#39;Form cannot be submitted yet.&#39;, event)&quot;&gt;
  Submit
&lt;/button&gt;
</code></pre>
<pre><code class="js">function warn(message, event) &#123;
  // 这里可以访问原生事件
  if (event) &#123;
    event.preventDefault()
  &#125;
  alert(message)
&#125;
</code></pre>
<h2 id="事件装饰符"><a href="#事件装饰符" class="headerlink" title="事件装饰符"></a>事件装饰符</h2><p>在处理事件时调用<code>event.preventDefault()</code>或<code>event.stopPropagation()</code>是很常见的。尽管我们可以直接在方法内调用，但如果方法能够专注于数据逻辑而不是去处理DOM事件的细节会更好。<br>为解决这一问题，vue为<code>v-on</code>提供了事件装饰符。修饰符是用<code>.</code>表示指令的后缀，包括如下这些：</p>
<p><code>.stop</code><br><code>.prevent</code><br><code>.self</code><br><code>.capture</code><br><code>.once</code><br><code>.passive</code></p>
<pre><code class="template">&lt;!-- 单击事件将停止传递 --&gt;
&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件将不再重新加载页面 --&gt;
&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰语可以使用链式书写 --&gt;
&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 也可以只有修饰符 --&gt;
&lt;form @submit.prevent&gt;&lt;/form&gt;

&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;
&lt;!-- 例如：事件处理器不来自子元素 --&gt;
&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre>
<p><code>.capture</code>、<code>.once</code>和<code>passive</code>修饰符与原生的<code>addEventListener</code>事件相对应</p>
<pre><code class="template">&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;
&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;
&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 点击事件最多被触发一次 --&gt;
&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;
&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;
&lt;div @scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;
</code></pre>
<p><code>.passive</code>修饰符一般用于触碰事件的监听器，可以用于改善移动端设备的滚屏性能。</p>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查特定的按键。vue允许在<code>v-on</code>或<code>@</code>监听按键事件时添加按键修饰符。</p>
<pre><code class="template">&lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;
&lt;input @keyup.enter=&quot;submit&quot; /&gt;
</code></pre>
<p>你可以直接使用<code>keyboardEvent.key</code>暴露的按键名称作为修饰符，但需要转为kebabcase形式</p>
<pre><code class="template">&lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt;
</code></pre>
<h3 id="按键别名"><a href="#按键别名" class="headerlink" title="按键别名"></a>按键别名</h3><p>vue为一些常用的按键提供了别名：<br><code>.enter</code><br><code>.tab</code><br><code>.delete</code>（捕获“Delete”和“Backspace”两个按键)<br><code>.esc</code><br><code>.space</code><br><code>.up</code><br><code>.down</code><br><code>.left</code><br><code>.right</code></p>
<h3 id="系统按键修饰符"><a href="#系统按键修饰符" class="headerlink" title="系统按键修饰符"></a>系统按键修饰符</h3><p>你可以使用如下系统修饰符来出发鼠标或键盘事件监听器，只有当按钮被按下时才会出发。<br><code>.ctrl</code><br><code>.alt`` </code>.shift<code> </code>.meta&#96;&#96;&#96;<br>举例来说：</p>
<pre><code class="template">&lt;!-- Alt + Enter --&gt;
&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;

&lt;!-- Ctrl + 点击 --&gt;
&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;
</code></pre>
<h3 id="exact修饰符"><a href="#exact修饰符" class="headerlink" title=".exact修饰符"></a><code>.exact</code>修饰符</h3><p><code>.exact</code>修饰符允许控制出发一个事件所需的确定组合的系统按键修饰符。</p>
<pre><code class="template">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;
&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;
&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;
&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre>
<h2 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h2><p><code>.left</code><br><code>.right</code><br><code>.middle</code><br>这些修饰符将处理程序限定为由特定鼠标按键触发的事件。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue/" style="color: #03a9f4">
                vue
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/web/" style="color: #00bcd4">
                web
            </a>
        </span>
        
    </div>
    <a href="/2022/09/11/vue-学习-4/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/04/vue-学习-3/">
        <h2 class="post-title">Vue-入门-2</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/4
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>主要学习了vue的类与样式绑定以及条件渲染等方面的知识</p>
<h1 id="数据板顶"><a href="#数据板顶" class="headerlink" title="数据板顶"></a>数据板顶</h1><p>数据绑定的一个常见需求是操作元素的CSS class列表和内嵌样式。因为<code>class</code>和<code>style</code>都是attribute，我们可以和其他attribute一样使用<code>v-bind</code>将它们与动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且容易出错的。因此，vue专门为<code>class</code>和<code>style</code>的<code>v-bind</code>用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p>
<h2 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h2><p>我们可以给<code>:class</code>(<code>v-bind:class</code>的缩写)传递一个对象来动态切换class：</p>
<pre><code class="template">&lt;div :class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>上面的语法表示<code>active</code>是否存在取决于数据属性<code>isActive</code>的真假值。<br>你可以在对象中写多个字段来操作多个class。此外，<code>:class</code>指令可以和一般的<code>class</code>attribute共存。</p>
<pre><code class="js">const isActive = ref(true)
const hasError = ref(false)
</code></pre>
<pre><code class="template">&lt;div
  class=&quot;static&quot;
  :class=&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;
&gt;&lt;/div&gt;
</code></pre>
<p>对应的渲染结果如下所示：</p>
<pre><code>&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;
</code></pre>
<p>当<code>isActive</code>或者<code>hasError</code>改变时，class列表会随之更新。距离来说，如果<code>hasError</code>变为true,class列表也会变成<code>static active text-danger</code>.<br>绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象：</p>
<pre><code class="js">const classObject = reactive(&#123;
  active: true,
  &#39;text-danger&#39;: false
&#125;)
</code></pre>
<pre><code class="template">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这也会渲染出同样的效果，我们也可以板顶一个返回对象的计算属性。这是一个常见且很有用的技巧：</p>
<pre><code class="js">const isActive = ref(true)
const error = ref(null)

const classObject = computed(() =&gt; (&#123;
  active: isActive.value &amp;&amp; !error.value,
  &#39;text-danger&#39;: error.value &amp;&amp; error.value.type === &#39;fatal&#39;
&#125;))
</code></pre>
<pre><code class="template">&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;
</code></pre>
<h3 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h3><p>我们可以给<code>:class</code>绑定一个数组来渲染多个CSS class:</p>
<pre><code class="js">const activeClass = ref(&#39;active&#39;)
const errorClass = ref(&#39;text-danger&#39;)
</code></pre>
<pre><code class="template">&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<p>渲染的结果是：</p>
<pre><code class="template">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;
</code></pre>
<p>如果你也在数组中有条件的渲染某个class，你可以使用三元表达式：</p>
<pre><code class="template">&lt;div :class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<p><code>errorClass</code>会一直存在，但是<code>activeClass</code>只会在<code>isActive</code>为真的时候存在。<br>然而，这可能是在由多个依赖条件的class时会有些冗长。因此可以在数组中嵌套对象。</p>
<pre><code class="template">&lt;div :class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<h3 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h3><p>对于只有一个根元素的组件，当你使用了<code>class</code>attribute时，这些class会被添加到根元素上，并与该元素已有的class合并<br>举例来说，如果你声明了以刚刚组件名叫<code>MyComponent</code>，模板如下：</p>
<pre><code class="template">&lt;!-- 子组件模板 --&gt;
&lt;p class=&quot;foo bar&quot;&gt;Hi!&lt;/p&gt;
</code></pre>
<p>在使用时添加一些class</p>
<pre><code class="template">&lt;!-- 在使用组件时 --&gt;
&lt;MyComponent class=&quot;baz boo&quot; /&gt;
</code></pre>
<p>渲染出的HTML为：</p>
<pre><code class="template">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;
</code></pre>
<p>Class 的绑定也是同样的：</p>
<pre><code class="template">&lt;MyComponent :class=&quot;&#123; active: isActive &#125;&quot; /&gt;
</code></pre>
<p>当<code>isActive</code>为真时，被渲染的HTML会是：</p>
<pre><code class="template">&lt;MyComponent :class=&quot;&#123; active: isActive &#125;&quot; /&gt;
</code></pre>
<p>如果你的组件有多个根元素，他将需要指定那个根元素来接受这个class。你可以通过组件的<code>$attrs</code>属性来实现指定：</p>
<pre><code class="template">&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;
&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;
&lt;span&gt;This is a child component&lt;/span&gt;
</code></pre>
<pre><code class="template">&lt;MyComponent class=&quot;baz&quot; /&gt;
</code></pre>
<p>这将被渲染为：</p>
<pre><code class="html">&lt;p class=&quot;baz&quot;&gt;Hi!&lt;/p&gt;
&lt;span&gt;This is a child component&lt;/span&gt;
</code></pre>
<h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="绑定对象-1"><a href="#绑定对象-1" class="headerlink" title="绑定对象"></a>绑定对象</h3><p><code>:style</code>支持绑定JavaScript对象值，对应的是HTML 元素的<code>style</code>属性：</p>
<pre><code class="js">const activeColor = ref(&#39;red&#39;)
const fontSize = ref(30)
</code></pre>
<pre><code class="template">&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>尽管推荐使用camelCase，但<code>:style</code>也支持kebab-cased形式的CSS 属性key(对应其css中的实际名称),例如：</p>
<pre><code class="template">&lt;div :style=&quot;&#123; &#39;font-size&#39;: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：</p>
<pre><code class="js">const styleObject = reactive(&#123;
  color: &#39;red&#39;,
  fontSize: &#39;13px&#39;
&#125;)
</code></pre>
<pre><code class="template">&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;
</code></pre>
<p>同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。</p>
<h3 id="绑定数组-1"><a href="#绑定数组-1" class="headerlink" title="绑定数组"></a>绑定数组</h3><p>我们还可以给<code>:style</code>绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一个元素上：</p>
<pre><code class="template">&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;
</code></pre>
<h3 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h3><p>当你在<code>:style</code>中使用了需要浏览器特殊前缀的CSS属性时，vue会为他们加上相应的前缀。vue是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将测试加上各个浏览器特殊前缀，以找到哪一个是被支持的。</p>
<h3 id="样式多值"><a href="#样式多值" class="headerlink" title="样式多值"></a>样式多值</h3><p>你可以对一个样式属性提供多个（不同前缀的）值，举例来说：</p>
<pre><code class="template">&lt;div :style=&quot;&#123; display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] &#125;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别的前缀的浏览器中都会渲染为<code>display:flex</code></p>
<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h2><p><code>v-if</code>指令用于条件性的渲染一块内容。这块内容只会在指令的表达式返回真值时才会渲染。</p>
<pre><code class="template">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;
</code></pre>
<h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a><code>v-else</code></h2><p>可以使用<code>v-else</code>为<code>v-if</code>添加一个”else 区块”。</p>
<pre><code class="template">&lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt;

&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;
&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;
</code></pre>
<p>一个<code>v-else</code>元素必须跟在一个<code>v-if</code>或者<code>v-else-if</code>元素后面，否则他不会被识别。</p>
<h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a><code>v-else-if</code></h2><p><code>v-else-if</code>提供的是相当于<code>v-if</code>的”else if 区块”.他可以连续多次重复使用。</p>
<pre><code class="template">&lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;
  A
&lt;/div&gt;
&lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;
  B
&lt;/div&gt;
&lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;
  C
&lt;/div&gt;
&lt;div v-else&gt;
  Not A/B/C
&lt;/div&gt;
</code></pre>
<p>和<code>v-else</code>类似，一个使用<code>v-else-if</code>的元素必须紧跟一个<code>v-if</code>或一个<code>v-else-if</code>元素后面。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue/" style="color: #00bcd4">
                vue
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/web/" style="color: #00a596">
                web
            </a>
        </span>
        
    </div>
    <a href="/2022/09/04/vue-学习-3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/03/vue-学习-2/">
        <h2 class="post-title">Vue-入门-2</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/3
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>该部分是对vue框架中响应式基础部分的学习</p>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue/" style="color: #03a9f4">
                vue
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/web/" style="color: #03a9f4">
                web
            </a>
        </span>
        
    </div>
    <a href="/2022/09/03/vue-学习-2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/02/算法模板-1/">
        <h2 class="post-title">算法模板-1</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>排序算法，二分算法以及高精度算法的模板实现</p>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/codeforce/" style="color: #ffa2c4">
                codeforce
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/c-c/" style="color: #ff7d73">
                c/c++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/algorithm/" style="color: #ffa2c4">
                algorithm
            </a>
        </span>
        
    </div>
    <a href="/2022/09/02/算法模板-1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/02/vue-学习-1/">
        <h2 class="post-title">Vue-入门-1</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>主要介绍的vue组件部分的相关知识，以及有关指令方面的说明。</p>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue/" style="color: #ffa2c4">
                vue
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/web/" style="color: #ffa2c4">
                web
            </a>
        </span>
        
    </div>
    <a href="/2022/09/02/vue-学习-1/" class="go-post">阅读全文</a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
    </div>
    <div class="next">
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="images/icon.jpg " alt="avatar">
        </div>
        <div class="name">
            ispoon
        </div>
        <div class="descriptions">
            
            <div class="description">
                ispoon YYDS
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/ispoon796">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 ispoon
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @ispoon
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>